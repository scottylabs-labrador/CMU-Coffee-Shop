import { jsx as P, jsxs as ke, Fragment as Fe } from "react/jsx-runtime";
import fe, { useState as te, useLayoutEffect as oe, useEffect as n, useRef as N, useImperativeHandle as je, useContext as ve, useMemo as De } from "react";
import { createPortal as he } from "react-dom";
var pe = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, He = typeof pe == "object" && pe && pe.Object === Object && pe, Te = typeof self == "object" && self && self.Object === Object && self;
He || Te || Function("return this")();
var Ke = typeof window < "u" ? oe : n, xe = typeof window > "u";
function Be(e, {
  defaultValue: u = !1,
  initializeWithValue: p = !0
} = {}) {
  const M = (v) => xe ? u : window.matchMedia(v).matches, [w, g] = te(() => p ? M(e) : u);
  function k() {
    g(M(e));
  }
  return Ke(() => {
    const v = window.matchMedia(e);
    return k(), v.addListener ? v.addListener(k) : v.addEventListener("change", k), () => {
      v.removeListener ? v.removeListener(k) : v.removeEventListener("change", k);
    };
  }, [e]), w;
}
const le = fe.createContext(null);
let me = null;
function Ne(e) {
  return me !== null || (me = new Promise((u) => {
    const p = document.createElement("script");
    p.addEventListener("load", () => {
      mapkit.init({
        authorizationCallback: (M) => M(e)
      }), u();
    }, { once: !0 }), p.src = "https://cdn.apple-mapkit.com/mk/5.x.x/mapkit.js", p.crossOrigin = "anonymous", document.head.appendChild(p);
  })), me;
}
var be = /* @__PURE__ */ ((e) => (e[e.Light = 0] = "Light", e[e.Dark = 1] = "Dark", e[e.Auto = 2] = "Auto", e))(be || {});
function Ve(e, u) {
  switch (e) {
    case 1:
      return mapkit.Map.ColorSchemes.Dark;
    case 0:
      return mapkit.Map.ColorSchemes.Light;
    case 2:
      return u ? mapkit.Map.ColorSchemes.Dark : mapkit.Map.ColorSchemes.Light;
    default:
      throw new RangeError("Invalid color scheme");
  }
}
var ye = /* @__PURE__ */ ((e) => (e[e.Standard = 0] = "Standard", e[e.MutedStandard = 1] = "MutedStandard", e[e.Hybrid = 2] = "Hybrid", e[e.Satellite = 3] = "Satellite", e))(ye || {});
function We(e) {
  switch (e) {
    case 0:
      return mapkit.Map.MapTypes.Standard;
    case 1:
      return mapkit.Map.MapTypes.MutedStandard;
    case 2:
      return mapkit.Map.MapTypes.Hybrid;
    case 3:
      return mapkit.Map.MapTypes.Satellite;
    default:
      throw new RangeError("Invalid map type");
  }
}
function Ge(e) {
  return {
    centerLatitude: e.center.latitude,
    centerLongitude: e.center.longitude,
    latitudeDelta: e.span.latitudeDelta,
    longitudeDelta: e.span.longitudeDelta
  };
}
function Ze(e) {
  switch (e) {
    case mapkit.Map.MapTypes.Standard:
      return 0;
    case mapkit.Map.MapTypes.MutedStandard:
      return 1;
    case mapkit.Map.MapTypes.Hybrid:
      return 2;
    case mapkit.Map.MapTypes.Satellite:
      return 3;
    default:
      throw new RangeError("Invalid map type");
  }
}
var Ae = /* @__PURE__ */ ((e) => (e[e.Adaptive = 0] = "Adaptive", e[e.Metric = 1] = "Metric", e[e.Imperial = 2] = "Imperial", e))(Ae || {});
function Ce(e) {
  switch (e) {
    case 0:
      return mapkit.Map.Distances.Adaptive;
    case 1:
      return mapkit.Map.Distances.Metric;
    case 2:
      return mapkit.Map.Distances.Imperial;
    default:
      throw new RangeError("Invalid distances value");
  }
}
var Re = /* @__PURE__ */ ((e) => (e[e.LandCover = 0] = "LandCover", e[e.PointsOfInterest = 1] = "PointsOfInterest", e[e.None = 2] = "None", e))(Re || {});
function Ue(e) {
  switch (e) {
    case 0:
      return mapkit.Map.LoadPriorities.LandCover;
    case 1:
      return mapkit.Map.LoadPriorities.PointsOfInterest;
    case 2:
      return mapkit.Map.LoadPriorities.None;
    default:
      throw new RangeError("Invalid load priority");
  }
}
function Se(e) {
  if (typeof e == "number") {
    if (e < 0 || e > 1e3)
      throw new RangeError("Display priority is out of range (0 to 1000)");
    return e;
  }
  switch (e) {
    case "low":
      return mapkit.Annotation.DisplayPriority.Low;
    case "high":
      return mapkit.Annotation.DisplayPriority.High;
    case "required":
      return mapkit.Annotation.DisplayPriority.Required;
    default:
      throw new RangeError("Invalid display priority");
  }
}
var ue = /* @__PURE__ */ ((e) => (e[e.Hidden = 0] = "Hidden", e[e.Visible = 1] = "Visible", e[e.Adaptive = 2] = "Adaptive", e))(ue || {});
function Me(e) {
  switch (e) {
    case 2:
      return mapkit.FeatureVisibility.Adaptive;
    case 1:
      return mapkit.FeatureVisibility.Visible;
    case 0:
      return mapkit.FeatureVisibility.Hidden;
    default:
      throw new RangeError("Invalid feature visibility");
  }
}
var qe = /* @__PURE__ */ ((e) => (e[e.Airport = 0] = "Airport", e[e.AmusementPark = 1] = "AmusementPark", e[e.Aquarium = 2] = "Aquarium", e[e.ATM = 3] = "ATM", e[e.Bakery = 4] = "Bakery", e[e.Bank = 5] = "Bank", e[e.Beach = 6] = "Beach", e[e.Brewery = 7] = "Brewery", e[e.Cafe = 8] = "Cafe", e[e.Campground = 9] = "Campground", e[e.CarRental = 10] = "CarRental", e[e.EVCharger = 11] = "EVCharger", e[e.FireStation = 12] = "FireStation", e[e.FitnessCenter = 13] = "FitnessCenter", e[e.FoodMarket = 14] = "FoodMarket", e[e.GasStation = 15] = "GasStation", e[e.Hospital = 16] = "Hospital", e[e.Hotel = 17] = "Hotel", e[e.Laundry = 18] = "Laundry", e[e.Library = 19] = "Library", e[e.Marina = 20] = "Marina", e[e.MovieTheater = 21] = "MovieTheater", e[e.Museum = 22] = "Museum", e[e.NationalPark = 23] = "NationalPark", e[e.Nightlife = 24] = "Nightlife", e[e.Park = 25] = "Park", e[e.Parking = 26] = "Parking", e[e.Pharmacy = 27] = "Pharmacy", e[e.Police = 28] = "Police", e[e.PostOffice = 29] = "PostOffice", e[e.PublicTransport = 30] = "PublicTransport", e[e.Restaurant = 31] = "Restaurant", e[e.Restroom = 32] = "Restroom", e[e.School = 33] = "School", e[e.Stadium = 34] = "Stadium", e[e.Store = 35] = "Store", e[e.Theater = 36] = "Theater", e[e.University = 37] = "University", e[e.Winery = 38] = "Winery", e[e.Zoo = 39] = "Zoo", e))(qe || {});
function ge(e) {
  switch (e) {
    case 0:
      return mapkit.PointOfInterestCategory.Airport;
    case 1:
      return mapkit.PointOfInterestCategory.AmusementPark;
    case 2:
      return mapkit.PointOfInterestCategory.Aquarium;
    case 3:
      return mapkit.PointOfInterestCategory.ATM;
    case 4:
      return mapkit.PointOfInterestCategory.Bakery;
    case 5:
      return mapkit.PointOfInterestCategory.Bank;
    case 6:
      return mapkit.PointOfInterestCategory.Beach;
    case 7:
      return mapkit.PointOfInterestCategory.Brewery;
    case 8:
      return mapkit.PointOfInterestCategory.Cafe;
    case 9:
      return mapkit.PointOfInterestCategory.Campground;
    case 10:
      return mapkit.PointOfInterestCategory.CarRental;
    case 11:
      return mapkit.PointOfInterestCategory.EVCharger;
    case 12:
      return mapkit.PointOfInterestCategory.FireStation;
    case 13:
      return mapkit.PointOfInterestCategory.FitnessCenter;
    case 14:
      return mapkit.PointOfInterestCategory.FoodMarket;
    case 15:
      return mapkit.PointOfInterestCategory.GasStation;
    case 16:
      return mapkit.PointOfInterestCategory.Hospital;
    case 17:
      return mapkit.PointOfInterestCategory.Hotel;
    case 18:
      return mapkit.PointOfInterestCategory.Laundry;
    case 19:
      return mapkit.PointOfInterestCategory.Library;
    case 20:
      return mapkit.PointOfInterestCategory.Marina;
    case 21:
      return mapkit.PointOfInterestCategory.MovieTheater;
    case 22:
      return mapkit.PointOfInterestCategory.Museum;
    case 23:
      return mapkit.PointOfInterestCategory.NationalPark;
    case 24:
      return mapkit.PointOfInterestCategory.Nightlife;
    case 25:
      return mapkit.PointOfInterestCategory.Park;
    case 26:
      return mapkit.PointOfInterestCategory.Parking;
    case 27:
      return mapkit.PointOfInterestCategory.Pharmacy;
    case 28:
      return mapkit.PointOfInterestCategory.Police;
    case 29:
      return mapkit.PointOfInterestCategory.PostOffice;
    case 30:
      return mapkit.PointOfInterestCategory.PublicTransport;
    case 31:
      return mapkit.PointOfInterestCategory.Restaurant;
    case 32:
      return mapkit.PointOfInterestCategory.Restroom;
    case 33:
      return mapkit.PointOfInterestCategory.School;
    case 34:
      return mapkit.PointOfInterestCategory.Stadium;
    case 35:
      return mapkit.PointOfInterestCategory.Store;
    case 36:
      return mapkit.PointOfInterestCategory.Theater;
    case 37:
      return mapkit.PointOfInterestCategory.University;
    case 38:
      return mapkit.PointOfInterestCategory.Winery;
    case 39:
      return mapkit.PointOfInterestCategory.Zoo;
    default:
      throw new RangeError("Invalid point of interest category");
  }
}
function Ee(e) {
  return new mapkit.CoordinateRegion(
    new mapkit.Coordinate(e.centerLatitude, e.centerLongitude),
    new mapkit.CoordinateSpan(e.latitudeDelta, e.longitudeDelta)
  );
}
function y(e, u, p, M) {
  n(() => {
    if (!e || !p)
      return;
    const w = (g) => {
      p(M(g));
    };
    return e.addEventListener(u, w), () => e.removeEventListener(u, w);
  }, [e, p]);
}
const $e = fe.forwardRef(({
  children: e = void 0,
  load: u,
  token: p,
  colorScheme: M = be.Light,
  mapType: w = ye.Standard,
  distances: g = Ae.Adaptive,
  loadPriority: k = Re.LandCover,
  isRotationEnabled: v = !0,
  isScrollEnabled: S = !0,
  isZoomEnabled: L = !0,
  showsCompass: H = ue.Adaptive,
  showsScale: T = ue.Hidden,
  showsMapTypeControl: V = !0,
  showsZoomControl: W = !0,
  showsUserLocationControl: G = !1,
  showsPointsOfInterest: m = !0,
  showsUserLocation: K = !1,
  tracksUserLocation: o = !1,
  allowWheelToZoom: x = !1,
  includedPOICategories: E = void 0,
  excludedPOICategories: F = void 0,
  paddingTop: c = 0,
  paddingRight: l = 0,
  paddingBottom: a = 0,
  paddingLeft: s = 0,
  initialRegion: b = void 0,
  cameraBoundary: A = void 0,
  minCameraDistance: B = 0,
  maxCameraDistance: X = 1 / 0,
  onLoad: Z = void 0,
  onRegionChangeStart: Y = void 0,
  onRegionChangeEnd: re = void 0,
  onMapTypeChange: ne = void 0,
  onSingleTap: ie = void 0,
  onDoubleTap: i = void 0,
  onLongPress: ae = void 0,
  onUserLocationChange: O = void 0,
  onUserLocationError: C = void 0,
  onClick: U = void 0,
  onMouseMove: r = void 0,
  onMouseDown: q = void 0,
  onMouseUp: j = void 0
}, Q) => {
  const [t, $] = te(null), D = N(null), I = N(!1);
  n(() => ((typeof u == "function" ? u : Ne)(p).then(() => {
    if (I.current)
      return;
    const h = b ? { region: Ee(b) } : {};
    $(new mapkit.Map(D.current, h)), I.current = !0;
  }), () => {
    t && (t.destroy(), I.current = !1);
  }), []), n(() => {
    t !== null && (Z == null || Z());
  }, [t]), je(Q, () => t, [t]);
  const d = Be("(prefers-color-scheme: dark)");
  n(() => {
    t && (t.colorScheme = Ve(M, d));
  }, [t, M, d]), n(() => {
    t && (t.mapType = We(w));
  }, [t, w]), n(() => {
    t && (t.distances = Ce(g));
  }, [t, g]), n(() => {
    t && (t.loadPriority = Ue(k));
  }, [t, k]), Object.entries({
    isRotationEnabled: v,
    isScrollEnabled: S,
    isZoomEnabled: L,
    showsMapTypeControl: V,
    showsZoomControl: W,
    showsUserLocationControl: G,
    showsPointsOfInterest: m,
    showsUserLocation: K,
    tracksUserLocation: o
  }).forEach(([R, h]) => {
    n(() => {
      t && (t[R] = h);
    }, [t, h]);
  }), Object.entries({
    showsCompass: H,
    showsScale: T
  }).forEach(([R, h]) => {
    n(() => {
      t && (t[R] = Me(h));
    }, [t, h]);
  }), n(() => {
    if (t)
      try {
        t._allowWheelToZoom = x;
      } catch {
      }
  }, [t, x]), n(() => {
    t && (t.padding = new mapkit.Padding(c, l, a, s));
  }, [t, c, l, a, s]), n(() => {
    t && (t.cameraBoundary = A ? Ee(A) : null);
  }, [t, A]), n(() => {
    t && (t.cameraZoomRange = new mapkit.CameraZoomRange(B, X));
  }, [t, B, X]), n(() => {
    if (t) {
      if (E && F)
        throw new Error("Canâ€™t specify both includedPOICategories and excludedPOICategories.");
      E ? t.pointOfInterestFilter = mapkit.PointOfInterestFilter.including(
        E.map(ge)
      ) : F ? t.pointOfInterestFilter = mapkit.PointOfInterestFilter.excluding(
        F.map(ge)
      ) : delete t.pointOfInterestFilter;
    }
  }, [t, E, F]);
  const se = () => Ge(t.region);
  y(t, "region-change-start", Y, se), y(t, "region-change-end", re, se), y(t, "map-type-change", ne, () => Ze(t.mapType));
  const f = ({ domEvents: R, pointOnPage: h }) => ({
    domEvents: R,
    pointOnPage: h,
    toCoordinates: () => t.convertPointOnPageToCoordinate(h)
  });
  return y(t, "single-tap", ie, f), y(t, "double-tap", i, f), y(t, "long-press", ae, f), y(t, "user-location-change", O, ({ coordinate: { latitude: R, longitude: h }, timestamp: ce, floorLevel: de }) => ({
    coordinate: { latitude: R, longitude: h },
    timestamp: ce,
    floorLevel: de
  })), y(t, "user-location-error", C, ({ code: R, message: h }) => ({ code: R, message: h })), [
    { name: "click", handler: U },
    { name: "mousemove", handler: r },
    { name: "mousedown", handler: q },
    { name: "mouseup", handler: j }
  ].forEach(({ name: R, handler: h }) => {
    n(() => {
      var de;
      if (!t || !h)
        return;
      const ce = (z) => {
        h({
          domEvents: [z],
          pointOnPage: { x: z.pageX, y: z.pageY },
          toCoordinates() {
            const { latitude: Le, longitude: Pe } = t.convertPointOnPageToCoordinate(new DOMPoint(z.pageX, z.pageY));
            return { latitude: Le, longitude: Pe };
          }
        });
      };
      return (de = D.current) == null || de.addEventListener(R, ce), () => {
        var z;
        return (z = D.current) == null ? void 0 : z.removeEventListener(R, ce);
      };
    }, [t, h]);
  }), /* @__PURE__ */ P(fe.StrictMode, { children: /* @__PURE__ */ P("div", { style: { width: "100%", height: "100%" }, ref: D, children: /* @__PURE__ */ P(le.Provider, { value: t, children: e }) }) });
}), _ = fe.forwardRef(({ children: e, type: u = "container" }, p) => /* @__PURE__ */ P("div", { className: `mk-callout-${u}`, ref: p, children: e }));
function Je({
  latitude: e,
  longitude: u,
  title: p = "",
  subtitle: M = "",
  accessibilityLabel: w = null,
  subtitleVisibility: g = ue.Adaptive,
  titleVisibility: k = ue.Adaptive,
  clusteringIdentifier: v = null,
  displayPriority: S = void 0,
  collisionMode: L = void 0,
  color: H = "#ff5b40",
  glyphColor: T = "white",
  glyphText: V = "",
  glyphImage: W = null,
  selectedGlyphImage: G = null,
  paddingTop: m = 0,
  paddingRight: K = 0,
  paddingBottom: o = 0,
  paddingLeft: x = 0,
  anchorOffsetX: E = 0,
  anchorOffsetY: F = 0,
  calloutElement: c = void 0,
  calloutContent: l = void 0,
  calloutLeftAccessory: a = void 0,
  calloutRightAccessory: s = void 0,
  calloutEnabled: b = void 0,
  calloutOffsetX: A = 0,
  calloutOffsetY: B = 0,
  selected: X = !1,
  animates: Z = !0,
  appearanceAnimation: Y = "",
  visible: re = !0,
  draggable: ne = !1,
  enabled: ie = !0,
  onSelect: i = void 0,
  onDeselect: ae = void 0,
  onDragStart: O = void 0,
  onDragEnd: C = void 0,
  onDragging: U = void 0
}) {
  const [r, q] = te(null), j = ve(le);
  n(() => {
    r && (r.subtitleVisibility = Me(g));
  }, [r, g]), n(() => {
    r && (r.titleVisibility = Me(k));
  }, [r, k]), n(() => {
    r && (r.padding = new mapkit.Padding(m, K, o, x));
  }, [r, m, K, o, x]), n(() => {
    r && (r.anchorOffset = new DOMPoint(E, F));
  }, [r, E, F]), n(() => {
    r && (r.calloutOffset = new DOMPoint(A, B));
  }, [r, A, B]);
  const Q = N(null), t = N(null), $ = N(null), D = N(null);
  oe(() => {
    if (!r)
      return;
    const f = {};
    return c && D.current !== null && (f.calloutElementForAnnotation = () => D.current), a && Q.current !== null && (f.calloutLeftAccessoryForAnnotation = () => Q.current), s && t.current !== null && (f.calloutRightAccessoryForAnnotation = () => t.current), l && $.current !== null && (f.calloutContentForAnnotation = () => $.current), Object.keys(f).length > 0 ? r.callout = f : delete r.callout, () => {
      delete r.callout;
    };
  }, [
    r,
    c,
    a,
    s,
    l,
    D.current,
    Q.current,
    t.current,
    $.current
  ]), n(() => {
    r && (L === "Circle" ? r.collisionMode = mapkit.Annotation.CollisionMode.Circle : L === "Rectangle" ? r.collisionMode = mapkit.Annotation.CollisionMode.Rectangle : delete r.collisionMode);
  }, [r, L]), n(() => {
    if (r) {
      if (S === void 0) {
        delete r.displayPriority;
        return;
      }
      r.displayPriority = Se(S);
    }
  }, [r, S]), Object.entries({
    title: p,
    subtitle: M,
    accessibilityLabel: w,
    color: H,
    glyphColor: T,
    glyphText: V,
    glyphImage: W,
    selectedGlyphImage: G,
    clusteringIdentifier: v,
    selected: X,
    animates: Z,
    appearanceAnimation: Y,
    draggable: ne,
    enabled: ie,
    visible: re,
    calloutEnabled: b
  }).forEach(([f, ee]) => {
    n(() => {
      if (r) {
        if (ee === void 0) {
          delete r[f];
          return;
        }
        r[f] = ee;
      }
    }, [r, ee]);
  });
  const d = () => {
  };
  [
    { name: "select", handler: i },
    { name: "deselect", handler: ae },
    { name: "drag-start", handler: O }
  ].forEach(({ name: f, handler: ee }) => {
    y(r, f, ee, d);
  });
  const we = () => ({
    latitude: r.coordinate.latitude,
    longitude: r.coordinate.longitude
  }), se = (f) => ({
    latitude: f.coordinate.latitude,
    longitude: f.coordinate.longitude
  });
  return y(r, "drag-end", C, we), y(r, "dragging", U, se), oe(() => {
    if (j === null)
      return;
    const f = new mapkit.MarkerAnnotation(
      new mapkit.Coordinate(e, u)
    );
    return j.addAnnotation(f), q(f), () => {
      j.removeAnnotation(f);
    };
  }, [j, e, u]), he(
    /* @__PURE__ */ ke("div", { style: { display: "none" }, children: [
      l !== void 0 && /* @__PURE__ */ P(
        _,
        {
          ref: $,
          type: "content",
          children: l
        }
      ),
      a !== void 0 && /* @__PURE__ */ P(
        _,
        {
          ref: Q,
          type: "left",
          children: a
        }
      ),
      s !== void 0 && /* @__PURE__ */ P(
        _,
        {
          ref: t,
          type: "right",
          children: s
        }
      ),
      c !== void 0 && /* @__PURE__ */ P(
        _,
        {
          ref: D,
          type: "container",
          children: c
        }
      )
    ] }),
    document.body
  );
}
function Xe({
  latitude: e,
  longitude: u,
  title: p = "",
  subtitle: M = "",
  accessibilityLabel: w = null,
  size: g = void 0,
  paddingTop: k = 0,
  paddingRight: v = 0,
  paddingBottom: S = 0,
  paddingLeft: L = 0,
  anchorOffsetX: H = 0,
  anchorOffsetY: T = 0,
  selected: V = !1,
  onSelect: W = void 0,
  onDeselect: G = void 0,
  onDragStart: m = void 0,
  onDragEnd: K = void 0,
  onDragging: o = void 0,
  animates: x = !0,
  appearanceAnimation: E = "",
  visible: F = !0,
  clusteringIdentifier: c = null,
  displayPriority: l = void 0,
  collisionMode: a = void 0,
  calloutElement: s = void 0,
  calloutContent: b = void 0,
  calloutLeftAccessory: A = void 0,
  calloutRightAccessory: B = void 0,
  calloutEnabled: X = void 0,
  calloutOffsetX: Z = 0,
  calloutOffsetY: Y = 0,
  draggable: re = !1,
  enabled: ne = !0,
  children: ie
}) {
  const [i, ae] = te(null), O = De(() => document.createElement("div"), []), C = ve(le);
  n(() => {
    i && (i.padding = new mapkit.Padding(k, v, S, L));
  }, [i, k, v, S, L]), n(() => {
    i && (i.anchorOffset = new DOMPoint(H, T));
  }, [i, H, T]), n(() => {
    i && (i.calloutOffset = new DOMPoint(Z, Y));
  }, [i, Z, Y]);
  const U = N(null), r = N(null), q = N(null), j = N(null);
  oe(() => {
    if (!i)
      return;
    const d = {};
    return s && j.current !== null && (d.calloutElementForAnnotation = () => j.current), A && U.current !== null && (d.calloutLeftAccessoryForAnnotation = () => U.current), B && r.current !== null && (d.calloutRightAccessoryForAnnotation = () => r.current), b && q.current !== null && (d.calloutContentForAnnotation = () => q.current), Object.keys(d).length > 0 ? i.callout = d : delete i.callout, () => {
      delete i.callout;
    };
  }, [
    i,
    s,
    A,
    B,
    b,
    j.current,
    U.current,
    r.current,
    q.current
  ]), n(() => {
    i && (a === "Circle" ? i.collisionMode = mapkit.Annotation.CollisionMode.Circle : a === "Rectangle" ? i.collisionMode = mapkit.Annotation.CollisionMode.Rectangle : delete i.collisionMode);
  }, [i, a]), n(() => {
    if (i) {
      if (l === void 0) {
        delete i.displayPriority;
        return;
      }
      i.displayPriority = Se(l);
    }
  }, [i, l]), Object.entries({
    title: p,
    subtitle: M,
    accessibilityLabel: w,
    size: g,
    selected: V,
    animates: x,
    appearanceAnimation: E,
    draggable: re,
    enabled: ne,
    visible: F,
    clusteringIdentifier: c,
    calloutEnabled: X
  }).forEach(([d, J]) => {
    n(() => {
      if (i) {
        if (J === void 0) {
          delete i[d];
          return;
        }
        i[d] = J;
      }
    }, [i, J]);
  });
  const t = () => {
  };
  [
    { name: "select", handler: W },
    { name: "deselect", handler: G },
    { name: "drag-start", handler: m }
  ].forEach(({ name: d, handler: J }) => {
    y(i, d, J, t);
  });
  const D = () => ({
    latitude: i.coordinate.latitude,
    longitude: i.coordinate.longitude
  }), I = (d) => ({
    latitude: d.coordinate.latitude,
    longitude: d.coordinate.longitude
  });
  return y(i, "drag-end", K, D), y(i, "dragging", o, I), oe(() => {
    if (C === null)
      return;
    const d = new mapkit.Annotation(
      new mapkit.Coordinate(e, u),
      () => O
    );
    return C.addAnnotation(d), ae(d), () => {
      C.removeAnnotation(d);
    };
  }, [C, e, u]), /* @__PURE__ */ ke(Fe, { children: [
    he(
      /* @__PURE__ */ ke("div", { style: { display: "none" }, children: [
        b !== void 0 && /* @__PURE__ */ P(
          _,
          {
            ref: q,
            type: "content",
            children: b
          }
        ),
        A !== void 0 && /* @__PURE__ */ P(
          _,
          {
            ref: U,
            type: "left",
            children: A
          }
        ),
        B !== void 0 && /* @__PURE__ */ P(
          _,
          {
            ref: r,
            type: "right",
            children: B
          }
        ),
        s !== void 0 && /* @__PURE__ */ P(
          _,
          {
            ref: j,
            type: "container",
            children: s
          }
        )
      ] }),
      document.body
    ),
    he(ie, O)
  ] });
}
function Ye({
  points: e,
  visible: u = !0,
  enabled: p = !0,
  selected: M = !1,
  onSelect: w = void 0,
  onDeselect: g = void 0,
  lineCap: k = "round",
  lineDash: v = [],
  lineDashOffset: S = 0,
  lineJoin: L = "round",
  lineWidth: H = 1,
  strokeColor: T = "rgb(0, 122, 255)",
  strokeOpacity: V = 1,
  strokeStart: W = 0,
  strokeEnd: G = 1
}) {
  const [m, K] = te(null), o = ve(le);
  return n(() => {
    if (o === null)
      return;
    const c = new mapkit.PolylineOverlay([]);
    return o.addOverlay(c), K(c), () => {
      o.removeOverlay(c);
    };
  }, [o]), n(() => {
    m !== null && (m.points = e.map(({ latitude: c, longitude: l }) => new mapkit.Coordinate(c, l)));
  }, [m, e]), Object.entries({ visible: u, enabled: p, selected: M }).forEach(([c, l]) => {
    n(() => {
      m && (m[c] = l);
    }, [m, l]);
  }), Object.entries({
    lineCap: k,
    lineDash: v,
    lineDashOffset: S,
    lineJoin: L,
    lineWidth: H,
    strokeColor: T,
    strokeOpacity: V,
    strokeStart: W,
    strokeEnd: G
  }).forEach(([c, l]) => {
    n(() => {
      m && (m.style[c] = l);
    }, [m, l]);
  }), [
    { name: "select", handler: w },
    { name: "deselect", handler: g }
  ].forEach(({ name: c, handler: l }) => {
    n(() => {
      if (!m || !l)
        return;
      const a = () => l();
      return m.addEventListener(c, a), () => m.removeEventListener(c, a);
    }, [m, l]);
  }), null;
}
function Oe({
  points: e,
  visible: u = !0,
  enabled: p = !0,
  selected: M = !1,
  onSelect: w = void 0,
  onDeselect: g = void 0,
  lineDash: k = [],
  lineDashOffset: v = 0,
  lineJoin: S = "round",
  lineWidth: L = 1,
  strokeColor: H = "rgb(0, 122, 255)",
  strokeOpacity: T = 1,
  strokeStart: V = 0,
  strokeEnd: W = 1,
  fillColor: G = "rgb(0, 122, 255)",
  fillOpacity: m = 0.1,
  fillRule: K = "nonzero"
}) {
  const [o, x] = te(null), E = ve(le);
  return n(() => {
    if (E === null)
      return;
    const a = new mapkit.PolygonOverlay([]);
    return E.addOverlay(a), x(a), () => {
      E.removeOverlay(a);
    };
  }, [E]), n(() => {
    if (o === null)
      return;
    if (!e || e.length === 0) {
      o.points = [];
      return;
    }
    const a = (s) => s.map(
      ({ latitude: b, longitude: A }) => new mapkit.Coordinate(b, A)
    );
    o.points = Array.isArray(e[0]) ? e.map(a) : a(e);
  }, [o, e]), Object.entries({ visible: u, enabled: p, selected: M }).forEach(([a, s]) => {
    n(() => {
      o && (o[a] = s);
    }, [o, s]);
  }), Object.entries({
    lineDash: k,
    lineDashOffset: v,
    lineJoin: S,
    lineWidth: L,
    strokeColor: H,
    strokeOpacity: T,
    strokeStart: V,
    strokeEnd: W,
    fillColor: G,
    fillOpacity: m,
    fillRule: K
  }).forEach(([a, s]) => {
    n(() => {
      o && (o.style[a] = s);
    }, [o, s]);
  }), [
    { name: "select", handler: w },
    { name: "deselect", handler: g }
  ].forEach(({ name: a, handler: s }) => {
    n(() => {
      if (!o || !s)
        return;
      const b = () => s();
      return o.addEventListener(a, b), () => o.removeEventListener(a, b);
    }, [o, s]);
  }), null;
}
export {
  Xe as Annotation,
  be as ColorScheme,
  Ae as Distances,
  ue as FeatureVisibility,
  Re as LoadPriority,
  $e as Map,
  ye as MapType,
  Je as Marker,
  qe as PointOfInterestCategory,
  Oe as Polygon,
  Ye as Polyline
};
